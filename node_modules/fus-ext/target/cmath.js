"use strict";
Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.atan = exports.asin = exports.acos = exports.tan = exports.sin = exports.cos = exports.sqrt = exports.pow = exports.log = exports.exp = exports.distance = exports.divide = exports.multiply = exports.subtract = exports.add = exports.phaseInDegrees = exports.phase = exports.abs = exports.conjugate = exports.reciprocal = exports.opposite = exports.approxEquals = exports.equals = undefined;

var _main = require("./main");

var dotDotCalc_573300145710716007 = function (dotDot, a, b, c) {
    return dotDot(a)[b](a, ...c);
};var equals, approxEquals, opposite, reciprocal, conjugate, abs, phase, phaseInDegrees, add, subtract, multiply, divide, distance, exp, log, pow, sqrt, cos, sin, tan, acos, asin, atan;exports.equals = equals = function (a, b) {
    return (() => {
        a = _main.Point.from(a);b = _main.Point.from(b);return a.x === b.x && a.y === b.y;
    })();
};exports.approxEquals = approxEquals = function (a, b) {
    return (() => {
        a = _main.Point.from(a);b = _main.Point.from(b);return dotDotCalc_573300145710716007(_main.dotDot_573300145710716007, a.x, "approxEquals", [b.x]) && dotDotCalc_573300145710716007(_main.dotDot_573300145710716007, a.y, "approxEquals", [b.y]);
    })();
};exports.opposite = opposite = function (p) {
    return (() => {
        p = _main.Point.from(p);return new _main.Point(-p.x, -p.y);
    })();
};exports.reciprocal = reciprocal = function (p) {
    return (() => {
        var n;p = _main.Point.from(p);n = p.x * p.x + p.y * p.y;return new _main.Point(p.x / n, -p.y / n);
    })();
};exports.conjugate = conjugate = function (p) {
    return (() => {
        p = _main.Point.from(p);return new _main.Point(p.x, -p.y);
    })();
};exports.abs = abs = function (p) {
    return (() => {
        p = _main.Point.from(p);return p.x === 0 ? (() => {
            return Math.abs(p.y);
        })() : (() => {
            return p.y === 0 ? (() => {
                return Math.abs(p.x);
            })() : (() => {
                return Math.sqrt(p.x * p.x + p.y * p.y);
            })();
        })();
    })();
};exports.phase = phase = function (p) {
    return (() => {
        p = _main.Point.from(p);return Math.atan2(p.y, p.x);
    })();
};exports.phaseInDegrees = phaseInDegrees = function (p) {
    return (() => {
        var d;p = _main.Point.from(p);return p.x === 0 && p.y === 0 ? (() => {
            return 0;
        })() : (() => {
            return p.x === 0 && p.y > 0 ? (() => {
                return 90;
            })() : (() => {
                return p.x === 0 && p.y < 0 ? (() => {
                    return -90;
                })() : (() => {
                    return p.x > 0 && p.y === 0 ? (() => {
                        return 0;
                    })() : (() => {
                        return p.x < 0 && p.y === 0 ? (() => {
                            return 180;
                        })() : (() => {
                            d = dotDotCalc_573300145710716007(_main.dotDot_573300145710716007, Math, "radiansToDegrees", [_main.cmath.phase(p)]);return d <= -180 ? (() => {
                                return 180;
                            })() : (() => {
                                return d;
                            })();
                        })();
                    })();
                })();
            })();
        })();
    })();
};exports.add = add = function (a, b) {
    return (() => {
        a = _main.Point.from(a);b = _main.Point.from(b);return new _main.Point(a.x + b.x, a.y + b.y);
    })();
};exports.subtract = subtract = function (a, b) {
    return (() => {
        return _main.cmath.add(a, _main.cmath.opposite(b));
    })();
};exports.multiply = multiply = function (a, b) {
    return (() => {
        a = _main.Point.from(a);b = _main.Point.from(b);return new _main.Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
    })();
};exports.divide = divide = function (a, b) {
    return (() => {
        var z;a = _main.Point.from(a);b = _main.Point.from(b);z = b.x * b.x + b.y * b.y;return new _main.Point((a.x * b.x + a.y * b.y) / z, (a.y * b.x - a.x * b.y) / z);
    })();
};exports.distance = distance = function (a, b) {
    return (() => {
        return _main.cmath.abs(_main.cmath.subtract(a, b));
    })();
};exports.exp = exp = function (p) {
    return (() => {
        p = _main.Point.from(p);return _main.Point.fromPolar(Math.exp(p.x), p.y);
    })();
};exports.log = log = function (p) {
    return (() => {
        return new _main.Point(Math.log(_main.cmath.abs(p)), _main.cmath.phase(p));
    })();
};exports.pow = pow = function (a, b) {
    return (() => {
        return _main.cmath.exp(_main.cmath.multiply(_main.cmath.log(a), b));
    })();
};exports.sqrt = sqrt = function (p) {
    return (() => {
        var r;p = _main.Point.from(p);r = _main.cmath.abs(p);return new _main.Point(Math.sqrt((r + p.x) / 2), Math.sign(p.y) * Math.sqrt((r - p.x) / 2));
    })();
};exports.cos = cos = function (p) {
    return (() => {
        return _main.cmath.divide(_main.cmath.add(_main.cmath.exp(_main.cmath.multiply(p, new _main.Point(0, 1))), _main.cmath.exp(_main.cmath.multiply(_main.cmath.opposite(p), new _main.Point(0, 1)))), 2);
    })();
};exports.sin = sin = function (p) {
    return (() => {
        return _main.cmath.divide(_main.cmath.subtract(_main.cmath.exp(_main.cmath.multiply(p, new _main.Point(0, 1))), _main.cmath.exp(_main.cmath.multiply(_main.cmath.opposite(p), new _main.Point(0, 1)))), new _main.Point(0, 2));
    })();
};exports.tan = tan = function (p) {
    return (() => {
        return _main.cmath.divide(_main.cmath.sin(p), _main.cmath.cos(p));
    })();
};exports.acos = acos = function (p) {
    return (() => {
        return _main.cmath.opposite(_main.cmath.multiply(_main.cmath.log(_main.cmath.add(p, _main.cmath.multiply(_main.cmath.sqrt(_main.cmath.add(_main.cmath.opposite(_main.cmath.multiply(p, p)), 1)), new _main.Point(0, 1)))), new _main.Point(0, 1)));
    })();
};exports.asin = asin = function (p) {
    return (() => {
        return _main.cmath.opposite(_main.cmath.multiply(_main.cmath.log(_main.cmath.add(_main.cmath.multiply(p, new _main.Point(0, 1)), _main.cmath.sqrt(_main.cmath.add(_main.cmath.opposite(_main.cmath.multiply(p, p)), 1)))), new _main.Point(0, 1)));
    })();
};exports.atan = atan = function (p) {
    return (() => {
        return _main.cmath.multiply(_main.cmath.subtract(_main.cmath.log(_main.cmath.subtract(1, _main.cmath.multiply(p, new _main.Point(0, 1)))), _main.cmath.log(_main.cmath.add(1, _main.cmath.multiply(p, new _main.Point(0, 1))))), new _main.Point(0, 0.5));
    })();
};exports.equals = equals;
exports.approxEquals = approxEquals;
exports.opposite = opposite;
exports.reciprocal = reciprocal;
exports.conjugate = conjugate;
exports.abs = abs;
exports.phase = phase;
exports.phaseInDegrees = phaseInDegrees;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.distance = distance;
exports.exp = exp;
exports.log = log;
exports.pow = pow;
exports.sqrt = sqrt;
exports.cos = cos;
exports.sin = sin;
exports.tan = tan;
exports.acos = acos;
exports.asin = asin;
exports.atan = atan;